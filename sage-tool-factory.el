;;; sage-tool-factory.el --- Self-extending tool system for sage -*- lexical-binding: t; -*-

;; Copyright (C) 2024 Jason Walsh
;; Author: Jason Walsh <j@wal.sh>
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))
;; Keywords: ai, tools, extensibility

;; This file is not part of GNU Emacs.

;;; Commentary:

;; This module allows sage to create new tools for itself.
;; Custom tools are persisted to a file and loaded on startup.
;;
;; Features:
;; - create_tool: Define new tools dynamically
;; - list_custom_tools: Show all user-defined tools
;; - delete_tool: Remove a custom tool
;; - reload_tools: Reload custom tools from disk
;;
;; Tools are stored in ~/.emacs.d/sage-custom-tools.el by default.

;;; Code:

(require 'cl-lib)

;; Forward declarations
(declare-function sage-tools--register "sage-tools" (name description parameters execute-fn))
(declare-function sage-tools--get-workspace "sage-tools" ())

(defvar sage-tools)

;;; Configuration

(defcustom sage-custom-tools-file
  (expand-file-name "sage-custom-tools.el" user-emacs-directory)
  "File where custom tools are persisted."
  :type 'file
  :group 'sage)

(defvar sage-custom-tools nil
  "List of custom tool definitions.")

;;; Tool Persistence

(defun sage-tool-factory--save-tools ()
  "Save custom tools to disk."
  (with-temp-file sage-custom-tools-file
    (insert ";;; sage-custom-tools.el --- Auto-generated custom tools -*- lexical-binding: t; -*-\n")
    (insert ";; This file is auto-generated by sage-tool-factory.\n")
    (insert ";; Do not edit manually.\n\n")
    (insert "(require 'sage-tool-factory)\n\n")
    (dolist (tool sage-custom-tools)
      (let ((name (alist-get 'name tool))
            (description (alist-get 'description tool))
            (parameters (alist-get 'parameters tool))
            (body (alist-get 'body tool)))
        (insert (format ";; Tool: %s\n" name))
        (insert (format "(sage-tool-factory--define-tool\n"))
        (insert (format " %S\n" name))
        (insert (format " %S\n" description))
        (insert (format " '%S\n" parameters))
        (insert (format " '%S)\n\n" body))))
    (insert "(provide 'sage-custom-tools)\n")
    (insert ";;; sage-custom-tools.el ends here\n"))
  (message "Saved %d custom tools to %s" (length sage-custom-tools) sage-custom-tools-file))

(defun sage-tool-factory--load-tools ()
  "Load custom tools from disk."
  (when (file-exists-p sage-custom-tools-file)
    (load sage-custom-tools-file t t)
    (message "Loaded custom tools from %s" sage-custom-tools-file)))

;;; Tool Definition

(defun sage-tool-factory--define-tool (name description parameters body)
  "Define and register a custom tool.
NAME is the tool name.
DESCRIPTION explains what it does.
PARAMETERS is the JSON schema.
BODY is a list form that will be evaluated with `args` bound."
  ;; Create the execute function
  (let ((fn (lambda (args)
              (eval `(let ((args ',args)) ,@body) t))))
    ;; Store in custom tools list (for persistence)
    (let ((existing (cl-find name sage-custom-tools
                             :key (lambda (t) (alist-get 'name t))
                             :test #'string=)))
      (if existing
          (setf (alist-get 'body existing) body
                (alist-get 'description existing) description
                (alist-get 'parameters existing) parameters)
        (push `((name . ,name)
                (description . ,description)
                (parameters . ,parameters)
                (body . ,body))
              sage-custom-tools)))
    ;; Register with sage-tools
    (when (fboundp 'sage-tools--register)
      (sage-tools--register name description parameters fn))
    name))

;;; Built-in Factory Tools

(defun sage--tool-create-tool (args)
  "Create a new custom tool.
ARGS should contain:
- name: Tool name (string)
- description: What the tool does (string)
- parameters: JSON schema for parameters (optional)
- code: Elisp code as a string that uses `args` variable"
  (let* ((name (alist-get 'name args))
         (description (alist-get 'description args))
         (parameters (or (alist-get 'parameters args)
                         '((type . "object")
                           (properties . ())
                           (required . []))))
         (code-string (alist-get 'code args))
         (body (condition-case err
                   (read (format "(%s)" code-string))
                 (error (error "Invalid elisp code: %s" (error-message-string err))))))
    (unless name (error "Tool name is required"))
    (unless description (error "Tool description is required"))
    (unless code-string (error "Tool code is required"))
    ;; Define the tool
    (sage-tool-factory--define-tool name description parameters body)
    ;; Save to disk
    (sage-tool-factory--save-tools)
    (format "Created tool '%s': %s" name description)))

(defun sage--tool-list-custom-tools (_args)
  "List all custom tools."
  (if sage-custom-tools
      (mapconcat
       (lambda (tool)
         (format "- %s: %s"
                 (alist-get 'name tool)
                 (alist-get 'description tool)))
       sage-custom-tools
       "\n")
    "No custom tools defined."))

(defun sage--tool-delete-tool (args)
  "Delete a custom tool."
  (let ((name (alist-get 'name args)))
    (unless name (error "Tool name is required"))
    (let ((tool (cl-find name sage-custom-tools
                         :key (lambda (t) (alist-get 'name t))
                         :test #'string=)))
      (if tool
          (progn
            (setq sage-custom-tools (cl-remove tool sage-custom-tools))
            ;; Remove from sage-tools
            (when (boundp 'sage-tools)
              (setq sage-tools
                    (cl-remove-if (lambda (t) (string= (alist-get 'name t) name))
                                  sage-tools)))
            (sage-tool-factory--save-tools)
            (format "Deleted tool: %s" name))
        (format "Tool not found: %s" name)))))

(defun sage--tool-reload-tools (_args)
  "Reload custom tools from disk."
  (setq sage-custom-tools nil)
  (sage-tool-factory--load-tools)
  (format "Reloaded %d custom tools" (length sage-custom-tools)))

;;; Pre-built Custom Tools

(defun sage-tool-factory--create-hackernews-tool ()
  "Create the Hacker News summarizer tool."
  (sage-tool-factory--define-tool
   "hackernews_summary"
   "Fetch and summarize top stories from Hacker News"
   '((type . "object")
     (properties . ((count . ((type . "integer")
                              (description . "Number of stories to fetch (default 10)")))))
     (required . []))
   '((require 'url)
     (let* ((count (or (alist-get 'count args) 10))
            (top-url "https://hacker-news.firebaseio.com/v0/topstories.json")
            (results '()))
       ;; Fetch top story IDs
       (condition-case err
           (let ((buffer (url-retrieve-synchronously top-url t nil 30)))
             (when buffer
               (with-current-buffer buffer
                 (goto-char (point-min))
                 (when (re-search-forward "\n\n" nil t)
                   (let* ((ids (json-read))
                          (top-ids (seq-take ids count)))
                     ;; Fetch each story
                     (dolist (id (append top-ids nil))
                       (let ((story-url (format "https://hacker-news.firebaseio.com/v0/item/%s.json" id)))
                         (condition-case nil
                             (let ((story-buf (url-retrieve-synchronously story-url t nil 10)))
                               (when story-buf
                                 (with-current-buffer story-buf
                                   (goto-char (point-min))
                                   (when (re-search-forward "\n\n" nil t)
                                     (let ((story (json-read)))
                                       (push (format "%d. %s\n   %s\n   %d points | %d comments"
                                                     (length results)
                                                     (alist-get 'title story)
                                                     (or (alist-get 'url story) "(no url)")
                                                     (or (alist-get 'score story) 0)
                                                     (or (alist-get 'descendants story) 0))
                                             results)))
                                   (kill-buffer story-buf))))
                           (error nil))))
                     (kill-buffer buffer))))))
         (error (format "Error fetching HN: %s" (error-message-string err))))
       (if results
           (concat "ðŸ”¶ Hacker News Top Stories\n\n"
                   (mapconcat #'identity (nreverse results) "\n\n"))
         "Failed to fetch Hacker News")))))

(defun sage-tool-factory--create-weather-tool ()
  "Create a weather tool using wttr.in."
  (sage-tool-factory--define-tool
   "weather"
   "Get current weather for a location using wttr.in"
   '((type . "object")
     (properties . ((location . ((type . "string")
                                 (description . "City name or location")))))
     (required . ["location"]))
   '((require 'url)
     (let* ((location (alist-get 'location args))
            (url (format "https://wttr.in/%s?format=%%l:+%%c+%%t+%%h+%%w"
                         (url-hexify-string location))))
       (condition-case err
           (let ((buffer (url-retrieve-synchronously url t nil 15)))
             (if buffer
                 (with-current-buffer buffer
                   (goto-char (point-min))
                   (when (re-search-forward "\n\n" nil t)
                     (let ((result (buffer-substring-no-properties (point) (point-max))))
                       (kill-buffer buffer)
                       (string-trim result))))
               "Failed to fetch weather"))
         (error (format "Weather error: %s" (error-message-string err))))))))

(defun sage-tool-factory--create-uuid-tool ()
  "Create a UUID generator tool."
  (sage-tool-factory--define-tool
   "generate_uuid"
   "Generate a random UUID"
   '((type . "object")
     (properties . ())
     (required . []))
   '((format "%04x%04x-%04x-%04x-%04x-%04x%04x%04x"
             (random 65536) (random 65536)
             (random 65536)
             (logior (logand (random 65536) 4095) 16384)
             (logior (logand (random 65536) 16383) 32768)
             (random 65536) (random 65536) (random 65536)))))

(defun sage-tool-factory--create-timestamp-tool ()
  "Create a timestamp tool."
  (sage-tool-factory--define-tool
   "timestamp"
   "Get current timestamp in various formats"
   '((type . "object")
     (properties . ((format . ((type . "string")
                               (description . "Format: iso, unix, rfc, or human")))))
     (required . []))
   '((let ((fmt (or (alist-get 'format args) "iso")))
       (pcase fmt
         ("unix" (format "%d" (float-time)))
         ("iso" (format-time-string "%Y-%m-%dT%H:%M:%SZ" nil t))
         ("rfc" (format-time-string "%a, %d %b %Y %H:%M:%S %z"))
         ("human" (format-time-string "%A, %B %d, %Y at %I:%M %p"))
         (_ (format "Unknown format: %s" fmt)))))))

;;; Tool Registration

;;;###autoload
(defun sage-tool-factory-init ()
  "Initialize the tool factory system."
  (interactive)
  ;; Register factory tools
  (when (fboundp 'sage-tools--register)
    (sage-tools--register
     "create_tool"
     "Create a new custom tool that persists across sessions"
     '((type . "object")
       (properties . ((name . ((type . "string")
                               (description . "Tool name (lowercase, underscores)")))
                      (description . ((type . "string")
                                      (description . "What the tool does")))
                      (parameters . ((type . "object")
                                     (description . "JSON schema for parameters")))
                      (code . ((type . "string")
                               (description . "Elisp code using 'args' variable")))))
       (required . ["name" "description" "code"]))
     #'sage--tool-create-tool)

    (sage-tools--register
     "list_custom_tools"
     "List all custom tools created by sage"
     '((type . "object")
       (properties . ())
       (required . []))
     #'sage--tool-list-custom-tools)

    (sage-tools--register
     "delete_tool"
     "Delete a custom tool"
     '((type . "object")
       (properties . ((name . ((type . "string")
                               (description . "Name of tool to delete")))))
       (required . ["name"]))
     #'sage--tool-delete-tool)

    (sage-tools--register
     "reload_tools"
     "Reload custom tools from disk"
     '((type . "object")
       (properties . ())
       (required . []))
     #'sage--tool-reload-tools))

  ;; Create built-in custom tools
  (sage-tool-factory--create-hackernews-tool)
  (sage-tool-factory--create-weather-tool)
  (sage-tool-factory--create-uuid-tool)
  (sage-tool-factory--create-timestamp-tool)

  ;; Load user's custom tools
  (sage-tool-factory--load-tools)

  (message "Tool factory initialized with %d custom tools"
           (length sage-custom-tools)))

(provide 'sage-tool-factory)
;;; sage-tool-factory.el ends here
